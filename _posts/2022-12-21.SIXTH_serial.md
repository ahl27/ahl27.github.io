---
title: '6502 FORTH, Part 3: Basic I/O'
date: 2022-12-21
permalink: /posts/2022/12/SIXTH-basicio/
tags:
  - blog posts
  - 6502
  - Forth
---

I've been posting about [creating a Forth interpreter for a 65c02](https://www.ahl27.com/posts/2022/12/SIXTHp1/), and at this point I'm pretty close to something that could be tested. However, I still need one more piece of infrastructure before I can begin writing and testing my Forth interpreter: some way to get and display user input.

My 6502 build includes a 65c22 VIA and 65c11 ACIA for general I/O and serial connections, respectively. The first step was to write some way to receive data over a serial connection. I found the datasheet at [this link](https://www.princeton.edu/~mae412/HANDOUTS/Datasheets/6551_acia.pdf), and started to figure out how to get my computer to interact with the world around it.

Serial Connections
---------------

The 65C51 ACIA adapter is a pretty nifty little device--it even includes an onboard baud rate generator (this is why the computer requires a 1.8432 MHz external clock). The Symon simulator I'm using maps the ACIA to addresses `$8000-8004`, and examples from their Github use a baud rate of 9600. The actual code to make this work is significantly less daunting than I expected.

{% highlight nasm %}
ACIA = $8000
ACIA_RX = ACIA         ; high here allows reading, low allows writing
ACIA_TX = ACIA
ACIA_STATUS = ACIA+1   ; Goes low when an interrupt occurs (?)
ACIA_COMMAND = ACIA+2
ACIA_CONTROL = ACIA+3  ; resets 

reset_acia:
  pha
  ; ACIA setup
  lda #$00
  sta ACIA_STATUS       ; writing anything to status resets the chip
  lda #$0B
  sta ACIA_COMMAND
  lda #$1E
  sta ACIA_CONTROL
  pla
  rts

acia_read:
  lda #$08
acia_rx_full:
  bit ACIA_STATUS       ; check to see if buffer is full (bit 3 is 1 if not empty)
  beq acia_rx_full
  lda ACIA_RX
  rts

{% endhighlight %}

This initial implementation is based off of [Michael Billington's original post](https://mike42.me/blog/2022-02-interfacing-an-nxp-uart-to-an-8-bit-computer). There's quite a few random hardcoded values in here, so let's break them down based on the information in the datasheet.

Starting with `reset_acia`, we push and pull to the a register at the beginning and end of the subroutine to preserve whatever was in the A register when we started. In the middle, we load three seemingly random values into three registers. The ACIA has four main addresses accessible to our computer: `R/TX, STATUS, COMMAND, CONTROL`. The first of these is the register that receives and transmits data depending on if we read or write to it (resp.). We'll come back to that register later.

The `STATUS` register is the simplest: the value at this address contains status of the ACIA device. Writing any value to this address resets the chip, which is why we start by writing `$00` to it. The other bits of note in this address are bits 3 and 4, which correspond to the the receiver/transmitter data registers being full/empty (resp.). This will come in handy in our read/write methods later on.

Next is the `COMMAND` register. This register, when written to, changes how the ACIA handles data. Bits 5-7 control parity check controls, bit 4 changes the receiver between normal and echo mode, and bits 0-3 change if interrupt signals are sent when sending data (and if so, how they're sent). I had initially planned to use these interrupt signals to trigger interrupts when data is ready to be read/written, but unfortunately I found out from [this forum post](http://forum.6502.org/viewtopic.php?f=4&t=5495) that the 65C51 ACIA has a hardware bug that renders all the interrupts essentially unusable. Instead, we'll have to disable them and rely on the 65C22's clock to trigger interrupts. For the `COMMAND` register, we're loading the value `$0B = 0000 0111`, corresponding to "Parity checks disabled", "Normal Receiver mode", "All interrupts disabled, receiver/transmitter enabled".

Finally, we have the `CONTROL` register, which controls how the ACIA works. Bit 7 controls number of stop bits, bits 5-6 control the length of each data word, bit 4 controls the clock source for generating baud rate, and the lower 4 bits control the baud rate. We load a value of `$1E = 0001 1110`, corresponding to "1 stop bit", "8 bit data word", "Baud rate generator", "9600 baud". If we wanted to process at 19200 baud, we would instead set the value to `$1F`.

Once we've set up the ACIA, we can write some methods to read data from the chip:

{% highlight nasm %}
acia_read:
  lda #$08
acia_rx_full:
  bit ACIA_STATUS       ; check to see if buffer is full (bit 3 is 1 if not empty)
  beq acia_rx_full
  lda ACIA_RX
  rts
{% endhighlight %}

Remember from before that bits 3 and 4 correspond to if the chip is ready to read/write. A `1` in bit 3 corresponds to a value of `0000 0100 = $08`, so we do a bitwise comparison between `$08` and the `STATUS` register to see if the data are ready to read. If they are, we read the value. `beq acia_rx_full` will branch if the result is 0, meaning if the `STATUS` register does not have a 1 in the third bit. If it does, the result is not zero and we can read the value out of the read register.



Next Steps
--------

This blog post is still a work in progress--I'll update it soon with the rest of the work I've completed on this today.
