---
title: '6502 FORTH, Part 3: 16 Bit Stack'
date: 2022-12-16
permalink: /posts/2022/12/SIXTHp3/
tags:
  - blog posts
  - 6502
  - Forth
---

In [my previous post](https://www.ahl27.com/posts/2022/12/SIXTHp2/), I created my first Forth words: `next`, `exit`, and `dolist`. I was about to continue on to creating some simple arithmetic words, but then I realized my program is missing the main data structure of Forth...the internal data stack. This is a 16-bit implementation, so I'll need a 16-bit stack. This of course is not included in the default 65c02 system, so I had to write one myself.

Stack Architecture
---------------

This implementation is largely based on [Paul Dourish's code](https://github.com/dourish/mitemon/blob/master/stack.a65), though I changed some of the implementations slightly. 

All of the 6502's registers are 8-bit except for its address bus. The memory map for the stack will look like the following:

```
$00FF       <- Bottom of stack
$00FE
$00FD          Stack will grow downward
  .
  .         <- x register points to current top
  .
$0082       <- Top possible address of stack 
$0081
$0080       <- 2 bytes of extra space for storing temp values
```

The stack occupies the top half of the zero page, and grows downward towards `$0080`. The final two bytes, `$0080-81`, are reserved for temporary values (for reasons that will soon become clear). The `x` register will hold the top of the stack, beginning at `$FF`. We can increase the size of the stack by decrementing `x` (`dex`), and decrease the size of the stack by incrementing `x` (`inx`). We'll have to implement the classic `push` and `pop` operations, but we're also going to implement `dup` (duplicate the top element), `add` and `sub` (add/subtract top elements, storing result as new top), and `swap` (swap top two elements of stack).

The stack is initialized as follows:
{% highlight nasm %}
stackaccess = $80

initstack:
  ldx #$FF              ; top of stack
  rts
{% endhighlight %}

`stackaccess` will store our temporary values, and the `x` register is initialized to `$FF` for the top of the stack. `initstack` will be called at the beginning of our program execution. Now we can get to creating the individual methods!

Push/Pop/Duplicate
---------

Push and pop are fairly straightforward, we just have to take care to preserve endianness for indirect addressing in other parts of our program. Our stack is growing downward, so we'll start by pushing the LSB first, then the MSB (to ensure the least significant byte is stored at the smallest address). This value will be pulled from `stackaccess`, our temp value. Let's look at pushing the value `$ABCD`:

```
0. Initial State

| $0080 | $0081 |  x  |  (x)  |
   $CD     $AB    $90     ?

1. Push MSB to x

| $0080 | $0081 |  x  |  (x)  |
   $CD     $AB    $90    $AB

2. Decrement x

| $0080 | $0081 |  x  |  (x)  |  (x-1)  |
   $CD     $AB    $89     ?       $AB

3. Push LSB to x
| $0080 | $0081 |  x  |  (x)  |  (x-1)  |
   $CD     $AB    $89    $CD      $AB

4. Decrement x

| $0080 | $0081 |  x  |  (x)  |  (x-1)  |
   $CD     $AB    $88     ?       $CD

Stack Layout:

$FF: some data
 .
 .
 .
$90: $AB
$89: $CD
$88:          <- x
``` 
Notice now how indirect indexing on `$89` will correctly read out the address `$ABCD`. The operation for `pop` is just this in reverse--we'll store the returned value in `stackaccess`. Putting it into code:

{% highlight nasm %}
;; Push a 16-bit value from stackaccess
push16:
  lda stackaccess+1     ; first byte (big end)
  sta x
  dex
  lda stackaccess       ; second byte (little end)
  sta x
  dex 
  rts

;; Pop a 16-bit value into stackaccess
pop16:
  inx                 ; start by moving up one place in stack
  lda x               
  sta stackaccess     ; first byte (big end)
  inx
  lda x               
  sta stackaccess+1   ; second byte (little end)
  rts

{% endhighlight %}

Duplicate is very similar to `push`, except we get the value from the top of the stack rather than from `stackaccess`. The previous value is the two bytes above `x` (`x+1,x+2`), so we just copy and increment `x` appropriately.

{% highlight nasm %}
;; Duplicate top value onto stack
dup16:
  lda x+2     ; load first byte of previous stack entry
  sta x       ; store it at top of stack
  dex         ; move to next byte          
  lda x+2     ; repeat for second byte
  sta x
  dex
  rts
{% endhighlight %}

Swap 
--------

Swap is a little trickier since we have to use a temporary variable. The basic flow of swap is the following:
```
Trying to swap top two values A,B
1. Copy A into stackaccess
2. Copy B onto A
3. Copy stackaccess onto B
```

Remember that our stack grows from top to bottom, and `x` always points to the next *free* byte of memory. Thus, the  value A from this example is stored at `x+1,x+2`, and the value B is stored at `x+3,x+4`.

{% highlight nasm %}
swap16:
  ; start by moving the top value into stackaccess
  lda x+1                     ; first byte of A in stackaccess
  sta stackaccess
  lda x+2                     ; second byte of A in stackaccess+1
  sta stackaccess+1

  ; copy second entry to top
  lda x+3
  sta x+1
  lda x+4
  sta x+2

  ; copy 2 bytes in stackaccess to second entry
  lda stackaccess
  sta x+3
  lda stackaccess+1
  sta x+4

  rts
  {% endhighlight %}


Add/Subtract
------------
Now we just need two more instructions, and we'll have a fully functioning Forth stack! These two commands are also very similar, and just implement simple 16-bit arithmetic. For addition, the flow looks like this:

```
x=$F0

# Adding $0405 + $0A10
$F4: $04
$F3: $05
$F2: $10
$F1: $0A

# Start with LSB, overwrite second value's LSB
# $05 + $10 = $15, no carry
$F4: $04
$F3: $15
$F2: $10
$F1: $0A

# Add MSB, overwrite second value's MSB
$ $0A + $10 = $1A, no carry
$F4: $1A
$F3: $15
$F2: $10
$F1: $0A

# increment x by two to 'pop' top value
x=$F2
```

The only trick to watch out for here is making sure the carry bit is set correctly--we have to be sure to clear the carry bit for addition, and set it for subtraction.

{% highlight nasm %}
;; Add top two values of stack, leaving result on top
add16:
  clc                 ; clear carry bit

  ; add lower byte (LSB) and store in second slot
  lda x+1
  adc x+3
  sta x+3

  ; add upper byte (MSB) and store in second slot
  lda x+2
  adc x+4
  sta x+4

  ; shrink the stack so the sum is now on top
  inx
  inx
  rts

;; Same as add16, but for subtract
sub16
  sec                 ; set carry bit

  ; subtract lower byte
  lda x+3
  sbc x+1
  sta x+3

  ; subtract upper byte
  lda x+4
  sbc x+2
  sta x+4

  ; shrink stack so difference is now on top
  inx
  inx
  rts
{% endhighlight %}


Next Steps
--------

That's all I need for a fully functioning stack! Now I have somewhere to put data, so I can write some words that store to and pull from the stack. Stay tuned for my next post, in which I plan to (hopefully) get some code actually running. I'm sure I'll discover some bugs in these codes then, but that'll be future me's problem. As always, you can check my complete code repository [on Github](https://github.com/ahl27/FORTH).
